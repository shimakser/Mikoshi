# Pipelines

**Pipelines** — Усовершенствование многотактовой архитектуры — Техника для повышения пропускной способности (throughput) процессора за счет одновременного выполнения нескольких инструкций на разных этапах. Т.к. в многотактовых микроархитектурах аппаратные компоненты часто простаивают.

_Принцип:_ Разделение выполнения инструкции на несколько этапов, каждый из которых занимает один такт, и перекрытие выполнения этих этапов для разных инструкций.

---

### Pipeline Stages
1. Выборка инструкции (Instruction Fetch, IF): Получение инструкции из памяти.
2. Декодирование инструкции и чтение регистрового файла (Instruction Decode & Register File Read, ID).
3. Выполнение операции / Вычисление адреса (Execute / Address Calculation, EX): Выполнение арифметической/логической операции или вычисление адреса для доступа к памяти.
4. Доступ к памяти (Memory Access, MEM): Чтение/запись данных из/в память (для инструкций LOAD/STORE).
5. Обратная запись результата в регистровый файл (Write Back, WB).

**Регистры конвейера (Pipeline registers)** —  латчи между этапами, которые хранят состояние инструкции, проходящей через конвейер.

_Преимущества:_ увеличивает количество инструкций, выполняемых за единицу времени. Среднее количество тактов на инструкцию (CPI) стремится к 1.

_Проблемы:_
- Накладные расходы на регистры конвейера (latches) между этапами, увеличивающие стоимость и энергопотребление.
- Конфликты (Hazards).
  - Конфликты по данным (Data Hazards): Следующая инструкция пытается использовать результат предыдущей, который еще не готов. Процессору приходится либо приостанавливать конвейер, либо использовать хитрые техники, чтобы передать результат напрямую со стадии на вход следующей команде, минуя запись в регистр.
  - Конфликты управления (Control Hazards): Возникают из-за команд ветвления (if-then-else). Процессор не знает заранее, какую инструкцию загружать следующей, пока не выполнится условие. Для решения этой проблемы были придуманы предсказатели ветвлений (branch predictors).

## Flow Dependences
Методы Обработки Зависимостей Данных.
- Обнаружение зависимости и ожидание: Инструкция ждет, пока значение не станет доступным в регистровом файле.
- Перенаправление/Шунтирование (Forwarding/Bypassing): Передача значения напрямую зависимой инструкции, как только оно становится доступным, без ожидания записи в регистровый файл.
- Предсказание значений (Value Prediction): Процессор спекулятивно предсказывает значение операнда и использует его, не дожидаясь его фактического вычисления. Если предсказание неверно, требуется rollback. Это может повысить производительность, особенно в суперскалярных процессорах.
- Внеочередное выполнение (Out-of-Order Execution): Если инструкция I2 зависит от I1, но в конвейере есть другие независимые инструкции (I3, I4), процессор может выполнить их вне очереди, пока I1 не завершится.
- Многопоточность (Multi-threading): Если один поток сталкивается с задержкой, вызванной зависимостями, процессор может переключиться на выполнение инструкций другого потока, используя его незанятые ресурсы конвейера.

## Control Dependences

Зависимости управления возникают из-за ветвлений (branches). Ветвления нарушают последовательный поток инструкций и могут привести к задержкам, если процессор выбирает инструкции по неверному пути.

### Стратегии обработки
1. Ожидание (Stalling): Простейший подход – остановка конвейера до разрешения ветвления. Крайне неэффективно.
2. Предсказание ветвлений (Branch Prediction): Процессор спекулятивно предсказывает исход ветвления (взято/не взято) и/или целевой адрес, чтобы выбрать инструкции по предсказанному пути.
   - Статические методы: Основаны на свойствах инструкций или потоке управления, известном на этапе компиляции.
   - Динамические методы: Используют историю прошлых ветвлений для предсказания будущего поведения.
3. Отложенные ветвления (Delayed Branches): Компилятор переупорядочивает инструкции, помещая инструкции, не зависящие от ветвления, в "слот задержки" (delay slot) после инструкции ветвления. Эти инструкции выполняются независимо от исхода ветвления.