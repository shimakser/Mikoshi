# Behavioral patterns

**1. Strategy**

- _Проблема:_ Нужно взаимозаменяемо использовать разные алгоритмы, не захламляя код if-else блоками.
- _Решение:_ Выделить алгоритмы в отдельные классы и подставлять их в рантайме через общий интерфейс.
- _Реализация:_
    - Пишем семейство объектов с общей абстракцией и методом.
    - Создаём конкретные независимые стратегии, реализующие свою логику.
    - Клиенту передаётся нужная стратегия, которую он вызывает через общий интерфейс (инжект или сеттер).

**2. Observer**

- _Проблема:_ Нужно, чтобы несколько объектов реагировали на изменения другого объекта.
- _Решение:_ Subject содержит список подписчиков (Observers) и уведомляет их.
  _Реализация:_
    - Создаём интерфейс Observer с методом update().
    - Пишем наследников, реализующих Observer.
    - Создаём класс Subject, который хранит коллекцию Observer-ов.

**3. Command**

- _Проблема:_ Нужно инкапсулировать запрос на выполнение действия, чтобы передавать, ставить в очередь, отменять и
  логировать
  команды.
- _Решение:_ Создать объекты с методом execute(), которые вызывают конкретные действия на получателе (Receiver).
- _Реализация:_
    - Создаём общий интерфейс Command с методом execute().
    - Наследники Command содержат ссылку на Receiver — объект, выполняющий реальную работу.
    - Внутри execute() команда делегирует вызов на Receiver.
    - Invoker вызывает команду, не зная её деталей.

**4. Chain of responsibility**

- _Проблема:_ Нужно, чтобы несколько объектов имели шанс обработать запрос, но не жёстко привязывать клиента к одному
  обработчику.
- _Решение:_ Создать цепочку обработчиков, где каждый либо обрабатывает сам, либо передаёт дальше.
- _Реализация:_
    - Создаём интерфейс Handler с методом handle(request) и ссылкой на next.
    - Каждый обработчик решает, обрабатывать ли запрос сам или передать дальше по цепочке к next.

**5. Iterator**

- _Проблема:_ Нужно перебирать элементы коллекции без раскрытия её структуры.
- _Решение:_ Создаём интерфейс Iterator с методами hasNext() и next().

**6. Mediator**

- _Проблема:_ Слишком много прямых связей между компонентами.
- _Решение:_ Вынести взаимодействие между объектами в один объект-посредник, который управляет коммуникацией.
- _Реализация:_
    - Определяем интерфейс Mediator с методами взаимодействия.
    - Все участники знают только медиатор, а не друг друга.
    - Медиатор получает события от объектов и решает, кому и как передать информацию.

**7. Memnto**

- _Проблема:_ Нужно сохранять и восстанавливать предыдущее состояние объекта, не нарушая его инкапсуляцию.
- _Решение:_ Создать отдельный класс-Memento, который содержит снимок состояния, и управлять этим через Caretaker.
- _Реализация:_
    - Создаём Memento, содержащий внутреннее состояние.
    - Originator создаёт снимок состояния и может восстановить себя из Memento.
    - Caretaker управляет сохранением и восстановлением снимков, не зная, что в них.

**8. State**

- _Проблема:_ Объект меняет поведение в зависимости от своего внутреннего состояния.
- _Решение:_ Вынести состояния в отдельные классы и делегировать поведение текущему состоянию.
- _Реализация:_
    - Определяем интерфейс State с методами поведения и наследников.
    - Контекст хранит текущее состояние и делегирует вызовы ему. Состояния могут переключать контекст (context.setState(
      newState)).

**9. Template method**

- _Проблема:_ Есть алгоритм с общим каркасом, но некоторые шаги меняются в подклассах.
- _Решение:_ Определить шаблонный метод в базовом классе, а переменные шаги сделать abstract или protected.
- _Реализация:_
    - Родительский класс содержит реализованный main метод. А шаги(участки main метода), которые будут отличаться у
      наследников — выносим в отельные abstract или protected методы.
    - Потомки реализуют конкретные шаги, не изменяя общую структуру алгоритма.

**10. Visitor**

- _Проблема:_ Нужно выполнять разные операции над объектами, но не менять сами классы объектов.
- _Решение:_ Вынести действия в отдельный класс-посетитель, который "заходит" в объекты и выполняет операцию.
- _Реализация:_
    - Создаём интерфейс Visitor с методами вида visit(Element).
    - Каждый элемент (Car, Wheel) реализует интерфейс Element с методом accept(Visitor).
    - accept() вызывает v.visit(this), что позволяет посетителю реализовать разные действия для разных классов.