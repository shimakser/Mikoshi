# Structural patterns

**1. Adapter**
- _Проблема:_ У тебя есть несовместимые интерфейсы. Нужно использовать сторонний(старый) класс, но его интерфейс не совпадает с тем, что ожидает твоя система.
- _Решение:_ Создать обёртку (адаптер), которая преобразует один интерфейс в другой.
- _Реализация:_
  - класс-адаптер имлиментирует типА (к которому нужно адаптировать) и инжектит типВ (который нужно адаптировать).
  - переопределят методы типА обращаясь к функционалу инжекта типВ.

**2. Briedge**
- _Проблема:_ Классы имеют много измерений вариаций (например: форма + цвет). Если делать наследование — получится много подклассов: RedCircle, GreenRectangle и т.д.
- _Решение:_ Разделить абстракцию и реализацию в отдельные иерархии, которые можно развивать независимо.
- _Реализация:_
  - Выносим Форму и Цвет в отдельные иерархии сущностей.
  - При необходимости "покрасить форму" — Форма инжектит Цвет.

**3. Composite**
- _Проблема:_ Нужно работать одинаково с одиночными объектами и группами объектов. Например, дерево меню или файловая система.
- _Решение:_ Построить иерархическую структуру, где узлы и листья реализуют один интерфейс.
- _Реализация:_
  - Создаём абстракцию, которая имеет 2 типа реализаций: реализация-объект и реализация-группаОбъектов.
  - реализация-группаОбъектов содержит внутри себя список родительской абстракции (которую сама и имлиментирует).

**4. Decorator**
- _Проблема:_ Нужно добавить функциональность объекту, но не хочется создавать кучу подклассов.
- _Решение:_ Обернуть объект другим объектом, который добавляет поведение, но реализует тот же интерфейс.
- _Реализация:_ Декоратор имлиментирует и инжектит тип, который нужно модифицировать.

**5. Flyweight**
- _Проблема:_ Ты создаёшь очень много похожих объектов, и это жрёт память.
- _Решение:_
  - Разделить объект на внутреннее (общие данные) и внешнее (уникальное) состояние.
  - Кэшировать и переиспользовать общую часть.
- _Реализация:_ Не создаём новый объект на каждый запрос, а переиспользуем закэшированное значение.

**6. Facade**
- _Проблема:_ Система имеет много сложных классов и взаимодействий, клиенту тяжело с ними работать.
- _Решение:_ Создать упрощённый интерфейс (фасад), который делегирует действия внутренним классам.
- _Реализация:_ создаём обьект GUI/MENU, выступающий центральной точкой запуска логики других обьектов.

**7. Proxy**
- _Проблема:_ Нужно контролировать доступ к объекту (например, логировать, кэшировать, проверять права) без изменения его кода.
- _Решение:_ Создать прокси-объект, который реализует тот же интерфейс и перехватывает вызовы.
- _Реализация:_ Прокси имлиментирует и инжектит тип, который нужно модифицировать.