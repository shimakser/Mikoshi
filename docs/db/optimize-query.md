# Optimizing DB queries


**EXPLAIN** используется для отображения плана выполнения запроса без его фактического выполнения. Он предоставляет информацию о том, как ядро базы данных планирует выполнить запрос, включая порядок доступа к таблицам, тип используемого соединения и индексы, которые будут использоваться.

**ANALYZE** используется для сбора статистики о данных в таблице или индексе. Эта информация используется оптимизатором запросов для принятия более эффективных решений о том, как выполнять запросы. ANALYZE обновляет статистику, используемую оптимизатором запросов, что может повысить производительность запросов.

Таким образом, EXPLAIN показывает, как будет выполняться запрос, а ANALYZE собирает статистику, помогающую оптимизировать выполнение запроса.

---

НО величина из EXPLAIN тоже не стабильная и зависит от многих параметров. Например, если диск долгое время был загружен, средняя стоимость изменится, то есть показатель снова будет необъективным. Чтобы это исправить, нужно добавить analyze:
explain analyze select ...

Но интереснее говорить не о костах и о времени выполнения — а о буферах. То есть о том, какой объем данных нам потребовался для выполнения конкретного запроса.
Буферы не завязаны на архитектуру, диск и память — они напрямую связаны именно с данными, которые хранятся на текущем сервере. Так что можно составить запрос таким образом:
explain (analyze, buffers) select ...

---

## Основные типы операций

1. Seq Scan — Последовательное сканирование таблицы (признак, что индекс не используется).
2. Index Scan — Чтение строк через индекс (точное попадание).
3. Bitmap Index Scan — Используется для более сложных условий, комбинируется с Bitmap Heap Scan.
4. Nested Loop — Цикл вложенного соединения (может быть очень дорогим при больших данных).
5. Hash Join — Быстрый join, если нет индексов.
6. Merge Join — Используется при отсортированных данных.
7. Aggregate — Агрегирующая операция (GROUP BY, COUNT, и т.д.).
8. Sort — Сортировка (часто дорогая операция без индекса).
9. Limit — Ограничение вывода.

---

## Пример

`EXPLAIN ANALYZE SELECT * FROM orders WHERE user_id = 123 AND created_at > '2024-01-01';`

**Response:**

`Index Scan using idx_user_created_at on orders  (cost=0.43..8.65 rows=5 width=120)
Index Cond: (user_id = 123 AND created_at > '2024-01-01')
Actual Rows: 3  Loops: 1
Buffers: shared hit=5`

**Разбор частей:**
1. Index Scan — Тип операции (по индексу). Бывают: Seq Scan, Index Scan, Bitmap, Nested Loop, и т.д.
2. using idx_user_created_at — Какой индекс используется.
3. Index Cond:  — Условия, по которым используется индекс (WHERE).
4. cost=0.43..8.65 — Планируемая "стоимость" запроса (чем меньше, тем лучше).
5. rows=5 — Ожидаемое число строк.
6. width=120 — Средний размер строки (в байтах).
7. Actual Rows: 3 — Фактически возвращено строк — полезно для анализа.
8. Loops: 1 — Сколько раз выполнялась операция (вложенные циклы).
9. Buffers — Использование памяти/диска (если включено track_io_timing).

---

## Как распознать проблемы

1. Seq Scan на большой таблице — Нет нужного индекса → создать его.
2. Rows сильно больше Actual Rows — Плохая статистика → выполнить ANALYZE.
3. Nested Loop с большими циклами — Может быть дорого → попробовать Hash Join, индекс или пересмотр запроса.
4. Sort — Нет индекса для ORDER BY → добавить индекс по сортируемому полю.
5. Bitmap Heap Scan — Часто работает, но может быть заменён на Index Scan.

---

## Практика

1. Пиши EXPLAIN ANALYZE <запрос> для всех медленных запросов.
2. Смотри:
   - Используется ли индекс?
   - Есть ли Seq Scan?
   - Есть ли Sort, Nested Loop, Filter?
3. Добавляй индексы по нужным колонкам с учётом порядка.
4. Повторяй EXPLAIN ANALYZE и смотри, стал ли план лучше.