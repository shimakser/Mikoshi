# Optimistic & Pessimistic Locking

| Тип блокировки  | Подход                 | Поведение                                                      |
| :-------------- | :--------------------- | :------------------------------------------------------------- |
| **Optimistic**  | "Конфликты — редкость" | Разрешает параллельную работу, проверяет конфликт при фиксации |
| **Pessimistic** | "Конфликты — норма"    | Блокирует данные заранее, чтобы избежать конфликтов            |


---

## Optimistic

### Как это работает
- Транзакция читает данные (например, строку с version = 5).
- Пользователь меняет запись и вызывает UPDATE.
- При сохранении Hibernate добавляет проверку WHERE version = 5.
- Если в БД уже version = 6 — обновление не сработает → выбрасывается исключение.

### Варианты реализации
1. **Version-based** — Использует поле версии в сущности. При обновлении проверяет, совпадает ли версия с текущей в БД. Если нет — возникает OptimisticLockException.

    _Пример:_
`       @Entity
       class Account {
           @Id Long id;
           BigDecimal balance;
           @Version 
           Integer version;
       }`

2. **Timestamp-based** — Альтернатива версионному подходу. Использует поле `last_modified_at` для проверки актуальности данных.
3. **Force Increment** — Увеличивает версию сущности даже при отсутствии изменений в её полях. Полезно при модификации связанных сущностей (например, в отношениях @OneToMany).
    
    _Пример_: `@Lock(LockModeType.OPTIMISTIC_FORCE_INCREMENT)`

- Данные не блокируются при чтении. Чтение из версии данных на момент начала транзакции
- Конфликты: Проверяется при фиксации, при конфликте — откат.
- Производительность: Высокая при низком уровне конфликтов.

### Недостатки
- Возможны откаты транзакций при частых конфликтах.
- При высокой конкуренции может потребоваться повторное выполнение транзакции.
- Не подходит для долгих бизнес-транзакций с большим окном между чтением и записью.

--- 

## Pessimistic

Транзакция захватывает ресурс заранее, чтобы другие транзакции не могли его изменить до завершения работы.
- Если другая транзакция попытается изменить те же данные — она ждёт (или получает ошибку “deadlock”).
- Гарантирует отсутствие конфликтов при коммите, но снижает параллелизм.

### Варианты реализации
1. **Блокировка чтения (PESSIMISTIC_READ)** — Позволяет читать, но запрещает другим записывать данные. Используется, если нужно гарантировать, что никто не изменит данные, пока мы читаем.
    
    _Пример:_ `entityManager.find(Entity.class, id, LockModeType.PESSIMISTIC_READ);`

2. **Блокировка записи (PESSIMISTIC_WRITE)** — Блокирует строку полностью — нельзя ни читать, ни изменять, пока блокировка не снята.

   _Пример:_ `entityManager.find(Entity.class, id, LockModeType.PESSIMISTIC_WRITE);`

3. **Force Increment (PESSIMISTIC_FORCE_INCREMENT)** — Комбинация блокировки записи с увеличением версии. Hibernate добавляет FOR UPDATE и обновляет версию — защита от параллельных обновлений даже связанных сущностей.

   _Пример:_ `@Lock(LockModeType.PESSIMISTIC_FORCE_INCREMENT)`

### Ключевые особенности
| Характеристика              | Описание                                         |
| :-------------------------- | :----------------------------------------------- |
| **Блокировки**              | Ставятся на уровне БД (`SELECT ... FOR UPDATE`)  |
| **Поведение при конфликте** | Вторая транзакция ждёт или получает deadlock     |
| **Производительность**      | Может снижаться из-за ожиданий                   |
| **Подходит для**            | Банковские системы, бронирования, склад, биллинг |
| **Проверка конфликтов**     | На уровне блокировки, а не версии                |

### Недостатки
- Может блокировать другие транзакции на длительное время.
- Возможны deadlocks, если порядок блокировок разный.
- Уменьшает масштабируемость в системах с высокой конкуренцией.