# Hibernate

### Важные интерфейсы
- **SessionFactory** — неизменяемый потокобезопасный объект, используется для получения объектов session. Кэширует мета-дату и SQL запросы которые часто используются приложением.
- **Session** — однопоточный короткоживущий, не потокобезопасный, объект, предоставляет связь между объектами приложения и БД и  является оберткой для jdbc подключения к БД.
- **Transaction** — однопоточный короткоживущий объект, используемый для атомарных операций.

### Требования JPA к Entity классам
- Должен быть отмечен аннотацией Entity или описан в XML файле конфигурации.
- Должен содержать public или protected конструктор без аргументов.
- Должен быть классом верхнего уровня (top-level class),
- Не может быть enum или интерфейсом.
- Не может быть финальным классом.
- Не может содержать финальные поля или методы, если они участвуют в маппинге.
- Если объект Entity класса будет передаваться по значению как отдельный объект, он так же должен реализовывать Serializable интерфейс.
- Поля должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity.
- Должен содержать первичный ключ.

### Каскадные связи: 
Если имеются зависимости между сущностями, то необходимо определить как различные операции будут влиять на другую сущность.
- **None**: без Cascading. Формально это не тип, но если мы не указали каскадной связи, то никакая операция для родителя не будет иметь эффекта для ребенка.
- **ALL**: save, delete, update, evict, lock, replicate, merge, persist.
- **SAVE_UPDATE**: save и update. Доступно только для hibernate.
- **DELETE**: передает в Hibernate native DELETE действие. Только для hibernate.
- **DETATCH**, **MERGE**, **PERSIST**, **REFRESH** и **REMOVE**, **LOCK**, **REPLICATE**.

### Шесть видов блокировок
- **NONE** — без блокировки.
- **OPTIMISTIC** — оптимистическая блокировка.
- **OPTIMISTIC_FORCE_INCREMENT** — оптимистическая блокировка с принудительным увеличением поля версионности.
- **PESSIMISTIC_READ** — пессимистичная блокировка на чтение.
- **PESSIMISTIC_WRITE** — пессимистичная блокировка на запись (и чтение).
- **PESSIMISTIC_FORCE_INCREMENT** — пессимистичная блокировка на запись (и чтение) с принудительным увеличением поля версионности.

---

## Flush

Этот метод есть как у JPA EntityManager:
`em.flush();`

так и у Hibernate Session:
`session.flush();`

Он транслирует изменения отслеживаемых сущностей в базу данных, то есть выполняет накопившиеся SQL-команды.

Режимы FlushMode.AUTO — Когда мы переводим entity из одного состояния в другое, то есть вызываем для них методы сохранения, удаления (persist(), merge(), remove()), немедленного выполнения SQL-команд не происходит. Команды накапливаются, а выполнение их откладывается на потом, до необходимого момента, а именно:
- до подтверждения транзакции (commit()),
- до выполнения JPQL и HQL запросов,
- до выполнения  native SQL запросов.
- либо до метода flush() — с помощью него мы можем явно выполнить накопившиеся SQL-команды.

Порядок сброса операций в базу — при сбросе изменений в базу операции выполняются в таком порядке:
- OrphanRemovalAction
- AbstractEntityInsertAction
- EntityUpdateAction
- QueuedOperationCollectionAction
- CollectionRemoveAction
- CollectionUpdateAction
- CollectionRecreateAction
- EntityDeleteAction

---

## Кэширование

1. **First-level cache:**
    - По умолчанию включен. 
    - Всегда привязан к объекту Session, его нельзя отключить.
    - При использовании методов save(), update(), saveOrUpdate(), load(), get(), list(), iterate(), scroll() всегда будет задействован кеш первого уровня.
2. **Second-level cache:**
   - По умолчанию отключен.
   - Привязан к объекту Session Factory. 
   - Hibernate не хранит объекты классов, он хранит информацию в виде массивов строк, чисел и т. д. И идентификатор объекта выступает указателем на эту информацию. Концептуально это нечто вроде Map, в которой id объекта — ключ, а массивы данных — значение.
   - Чтение из кеша второго уровня происходит только в том случае, если нужный объект не был найден в кеше первого уровня.
   - Пять значений shared-cache-mode из persistence.xml, который определяет как будет использоваться second-level cache:
     - ALL — все Entity могут кэшироваться.
     - NONE — кеширование отключено для всех.
     - ENABLE_SELECTIVE — кэширование работает только для тех Entity, у которых установлена аннотация Cacheable(true) или её xml эквивалент, для всех остальных кэширование отключено,
     - DISABLE_SELECTIVE — кэширование работает для всех Entity, за исключением тех у которых установлена аннотация Cacheable(false) или её xml эквивалент.
     - UNSPECIFIED — кеширование не определенно, каждый провайдер JPA использует свою значение по умолчанию.
3. **Third-level cache:**: 
   - По умолчанию отключен. 
   - Кеш запросов похож на кеш второго уровня: ключом к данным кеша выступает не id объекта, а совокупность параметров запроса. А сами данные — это идентификаторы объектов соответствующих критериям запроса.

`@Cacheable` — позволяет включить или выключить использование кеша второго уровня (second-level cache) для данного Entity.

**Методы сессии:**
- flush() — синхронизирует объекты сессии с БД и в то же время обновляет сам кеш сессии.
- evict() — нужен для удаления объекта из кеша cессии.
- contains() — определяет находится ли объект в кеше сессии или нет.
- clear() — очищает весь кеш.

---

## N+1

Проблема N+1 возникает, когда фреймворк доступа к данным выполняет N дополнительных SQL-запросов для получения тех же данных, которые можно получить при выполнении одного SQL-запроса.

1. Использование явного или неявного FetchType.EAGER для JPA-ассоциаций — плохая идея, будет загружаться гораздо больше данных, чем вам нужно. 
А FetchType.EAGER также подвержена проблемам N+1. К сожалению, ассоциации @ManyToOne и @OneToOne по умолчанию используют FetchType.EAGER.
Если вам совсем не нужна ассоциация с post, то не повезло: с использованием FetchType.EAGER нет способа избежать ее получения. Поэтому по умолчанию лучше использовать FetchType.LAZY.
Но если вы хотите использовать ассоциацию с post, то можно использовать JOIN FETCH, чтобы избежать проблемы с N+1.

2. Даже если вы явно перейдете на использование FetchType.LAZY для всех ассоциаций, то вы все равно можете столкнуться с проблемой N+1.
   Первоначально Hibernate выполнит один запрос. Но позже, при обращении к lazy-load ассоциации будет получен N+1 запрос. Поскольку ассоциация загружается лениво, при доступе к этой ассоциации будет выполняться дополнительный SQL-запрос для получения нужных данных.

3. Проблема N+1 также может возникать при использовании кэша второго уровня для обработки коллекций или результатов запроса. 
4. В кэше запросов хранятся только идентификаторы сущностей. Если сущности не находятся в кэше, они будут извлечены из базы данных и вы получите N дополнительных SQL-запросов.


### Решение

1. **Entity Graph** — позволяет улучшить производительность во время выполнения запросов к БД при загрузке связанных ассоциаций и основных полей объекта. JPA Entity Graph загружает данные в один запрос выбора, избегая повторного обращения к базе данных. 
Это считается хорошим подходом для повышения производительности приложений.

    Пишем аннотацию @EntityGraph над методом в репозитории. По умолчания @EntityGraph имеет тип EntityGraphType.FETCH и он применяет стратегию FetchType.EAGER к указанным атрибутам, то есть к emails.


    interface Repo extends JpaRepository<Client, I> {
        @EntityGraph(type = EntityGraph.EntityGraphType.FETCH, attributePaths = "emails")
        List<Client> findByName(String name);
    }

2. Пишем аннотацию @NamedEntityGraph над классом Client:


    @Entity
    @NamedEntityGraph(name = "client_entity-graph", attributeNodes = @NamedAttributeNode("emailAddresses"))
    public class Client {}

В данном случае также будет использоваться "жадная" загрузка указанной связной сущности emails.
Также необходимо исправить аннотацию над Repository.


    interface Repository extends JpaRepository<Client, I> {
        @EntityGraph(type = EntityGraph.EntityGraphType.FETCH, value = "client_entity-graph")
        List<Client> findByName(String name);
    }

3. **@BatchSize**

Преобразует запрос к БД в: `SELECT * FROM employee WHERE department_id IN (?, ?, ?, ..., ?)`

_Пример:_
Если size = 10, и мы получили 20 Department:
Обратимся к getEmployees() у первого — Hibernate загрузит сразу 10 department_id в одном запросе.
При следующем обращении — подгрузит оставшиеся 10.
Итог: 2 запроса вместо 20.

---

## Cartesian product problem

Столкнуться с проблемой декартового произведения можно как явно (просто написав Query с несколькими join), так и неявно, выполнив find() для сущности с EAGER-коллекциями (Hibernate при этом сгенерирует SQL с несколькими join).

**Декартово произведение** — ситуация, когда на выбор N элементов из одной таблицы и M элементов из другой таблицы база данных возвращает N*M строк.

В Hibernate проблема декартова произведения возникает при использовании EAGER-загрузки коллекций, когда Hibernate генерирует SQL-запрос с несколькими join. Чем больше коллекций необходимо загрузить, тем больше join будет в SQL-запросе и тем больше будет декартово произведение в результате. Это может привести к выборке огромного количества лишних данных, которые передаются по сети, занимают оперативную память и отрицательно сказываются на производительности

### Решение
Способ заполнить коллекции постов, при этом избежав проблемы как декартова произведения, так и N+1: аннотируем обе коллекции с `@Fetch(FetchMode.SUBSELECT)`.