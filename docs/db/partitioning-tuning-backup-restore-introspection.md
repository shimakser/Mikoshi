# Partitioning, Tuning, Backup/Restore, Introspection

## Partitioning

Разделение одной логической таблицы на физические "части" (partition’ы), чтобы улучшить масштабируемость, читаемость, удаление старых данных и производительность.

### Виды партиционирования
1. Range Partitioning
   - Делит данные по диапазону значений.
   - Пример: created_at < 2024-01-01.
   - Используется для логов, заказов, событий по времени.
2. List Partitioning
   - Деление по конкретным значениями.
   - Пример: "region = 'USA'", "region = 'EU'".
3. Hash Partitioning
   - Делит записи по хешу значения (ID).
   - Равномерно распределяет данные.
   - Используется при горизонтальном масштабировании и балансировке нагрузки.
4. Composite Partitioning
   - Комбинация двух и более видов.
   - Например: RANGE по дате + HASH по user_id.
   - Используется в очень больших таблицах, где важно контролировать и дату, и распределение.

### Преимущества
- Ускорение запросов (partition pruning).
- Гибкое масштабирование.
- Уменьшение блокировок.

### Пример для PostgreSQL
1. Определяет главную таблицу, но без данных. Она служит "контейнером" для партиций.


    CREATE TABLE orders (
       id SERIAL PRIMARY KEY,
       customer_id INT NOT NULL,
       status TEXT NOT NULL,
       created_at DATE NOT NULL
    ) PARTITION BY RANGE (created_at);
2. Каждая партиция — это отдельная физическая таблица, автоматически подключённая к родительской.
   
   
    CREATE TABLE orders_2023 PARTITION OF orders
    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');

---

## DB Tuning

1. Память
    
    1.1 PostgreSQL
    - shared_buffers: кэш страниц. Обычно 25–40% RAM.
    - work_mem: память для сортировок/хешей.
    - effective_cache_size: предполагаемый размер доступного ОС кэша.
    
    1.2 MySQL
    - innodb_buffer_pool_size: главный кэш для таблиц и индексов.
2. Планировщик
   - random_page_cost, seq_page_cost — как "дороги" между планами.
   - Настройка этих параметров влияет на выбор Index Scan vs Seq Scan.
3. Статистика
  ANALYZE / VACUUM ANALYZE / UPDATE STATISTICS:
   - Обновляют статистику распределения значений.
   - Без неё Query Planner выбирает плохой план.
4. Журнализация
   - Проверить настройки WAL (PostgreSQL), binlog (MySQL).
5. Параллелизм
   - Использовать parallel queries (max_parallel_workers_per_gather).
   - В PostgreSQL включить parallel_tuple_cost, parallel_setup_cost.

---

## Backup & Restore

### Виды backup
1. **Full Backup** — Снимок всей БД. Подходит для небольших БД или low-traffic.
   
    _Особенности:_
    - Самый надёжный и простой тип — восстанавливает систему "как была".
    - Может быть логический (через SQL-дамп) или физический (копия файлов/страниц данных).
    - Минус — большой объём данных и высокая нагрузка при создании.

    _Когда применять:_
    - Малые и средние базы (<50–100 ГБ).
    - Низкая интенсивность записи.
    - Начальная точка для инкрементальных бэкапов.
    
| СУБД       | Инструмент                             | Тип                     |
| ---------- | -------------------------------------- | ----------------------- |
| PostgreSQL | `pg_dump`, `pg_basebackup`             | логический / физический |
| MySQL      | `mysqldump`, `mysqlpump`, `xtrabackup` | логический / физический |
| SQL Server | `BACKUP DATABASE` (T-SQL)              | физический              |
| Oracle     | `RMAN`                                 | физический              |

2. **Incremental / Differential Backup** (Инкрементальные и дифференциальные)
    
    2.1 **Incremental** — Сохраняет только изменения с момента последнего любого бэкапа (любого типа — full или incremental).
    
    2.2 **Differential** — Сохраняет изменения с момента последнего полного бэкапа.

   - _Плюсы:_
     - Меньший объём.
     - Быстрое выполнение.
   - _Минусы:_
     - Для восстановления нужно собрать цепочку (full + все инкрементальные).
     - Повышенный риск несогласованности, если часть цепочки повреждена.
   - _Инструменты:_
     - PostgreSQL: физический инкремент через pg_basebackup + WAL.
     - MySQL: binlog.
     - SQL Server: BACKUP DATABASE ... WITH DIFFERENTIAL.

3. **WAL / Binlog Backup (Журнал изменений)** — Журнал транзакций (WAL — Write-Ahead Log в PostgreSQL, binlog — в MySQL), фиксирующий все изменения на уровне страниц или транзакций.
    - _Назначение:_
      - Восстановление до любого момента времени (Point-in-Time Recovery, PITR).
      - Инкрементальное копирование на уровне логов.

#### Cold vs Hot Backup

| Тип             | Описание                                           | Преимущества                    | Недостатки                                                  |
| --------------- | -------------------------------------------------- | ------------------------------- | ----------------------------------------------------------- |
| **Cold Backup** | Копирование при **остановленной БД**               | Простота, консистентность       | Downtime                                                    |
| **Hot Backup**  | Копирование при **работающей БД** (с snapshot/WAL) | Нет простоев, актуальные данные | Требует механизма согласованности (snapshot, WAL archiving) |

**Cold Backup чаще делается для:**
- небольших БД,
- QA/тест окружений.

**Hot Backup — для production:**
- _PostgreSQL:_ pg_basebackup, LVM snapshot, pgBackRest.
- _MySQL:_ xtrabackup (Percona) — позволяет копировать живую базу без блокировки.

#### Logical vs Physical Backup

| Тип          | Что копирует                  | Применение                       | Инструменты                         |
| ------------ | ----------------------------- | -------------------------------- | ----------------------------------- |
| **Logical**  | SQL-структуры и данные (дамп) | Перенос между версиями, миграции | `pg_dump`, `mysqldump`              |
| **Physical** | Файлы, блоки данных, WAL      | Быстрое восстановление, PITR     | `pg_basebackup`, `xtrabackup`, RMAN |



### Restore
- Важно: restore ≠ просто копировать dump → нужна и структура, и WAL/binary логи.
- Убедись, что можно восстановить до точки во времени.
- Тестируй регулярно restore pipeline.

---

## Introspection
Умение "заглянуть внутрь БД", чтобы понять, как она реально работает, какие запросы грузят систему, какие таблицы используются часто, какие индексы — нет.

### Инструменты
1. PostgreSQL
   - pg_stat_activity — активные запросы.
   - pg_stat_statements — статистика запросов.
   - pg_indexes, pg_class, pg_attribute — структура и индексы.
   - auto_explain, pg_buffercache, pg_stat_user_tables.
2. MySQL
   - INFORMATION_SCHEMA.
   - SHOW FULL PROCESSLIST, SHOW STATUS, SHOW TABLE STATUS.
   - performance_schema.
   - EXPLAIN ANALYZE.

### Что анализировать
1. Запросы
   - Частоиспользуемые
   - Долгие (slow query log)
   - Частые ошибки
2. Таблицы и индексы
   - Размеры таблиц
   - Использование индексов (hit ratio)
   - Неиспользуемые или дублирующие индексы
3. Конфигурации
   - Использование памяти
   - Журнализация
   - Автоматическое обновление статистики

---

## Метрики

- **Buffer cache hit ratio** — Доля обращений, обработанных из кэша.
- **Index hit ratio** — Как часто используются индексы.
- **Long-running queries** — Подозрительные тормоза.
- **Deadlocks** — Проблемы параллелизма.
- **Connection count** — Нагрузка на пул соединений.