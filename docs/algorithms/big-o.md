# Big O

Концепция Big O показывает, какое количество шагов (тактов процессора) необходимо сделать, чтобы полностью завершить алгоритм.


```java
   
время
   .          
  / \       /
   |       /
   |      /  O(n)
   |     /
   |    /
   |   /
   |  /
   |-/------------------- O(1)
   |/
   |
   o——————————————————> 
                кол-во бит
```

### Отбрасывание неважной сложности

Eсли одно значение n значительно (в 2 раза) меньше другого значения n^2, то меньшуу n можно отбросить, т.к. она слабо влияет на рост скорости фукнции.

O(n^2 + n) = O(n^2)

O(n + log n) = O(n), т.к log(n) меньше n

O(5 * 2^n + 10 * n^100) = O(2^n)

O(n^2 + b) = O(n^2 + b), мы не может упростить, пока ничего не знаем о b. Оно может быть <, > или = n.

### Сложение и умножение сложностей

Если функции вызываются последовательно, то сложности складываются (они не зависят друг от друга). Если функции выполняются одна в другой (зависят друг от друга) то сложности умножаются.

Log n - для алгоритма, где на каждой итерации берется половина элементов - сложность будет включать O(log n).


---

- **O(n)** — Больше байт - дольше передавать. Зависимость от количества элементов. В функции это кол-во вызовов функции внутри себя.
- **О(1)** — Размер файла не важен, скорость постоянна.
- **O(log n)** — алгоритм, где на каждой итерации берется половина элементов (бинарный поиск).
- **O(n^2)** — вложенный цикл.

**Важно:** алгоритм со сложностью O(1) может спокойно быть в тысячу раз медленнее алгоритма O(N!), для ваших данных. Поэтому стоит понимать, что Big O говорит только о скорости роста времени выполнения алгоритма, о самой скорости алгоритма эта нотация вообще ничего не скажет.
