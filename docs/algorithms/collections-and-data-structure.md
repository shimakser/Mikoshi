# Collections and Data structure


## ArrayList vs LinkedList

### ArrayList
- доступ к произвольному элементу по индексу за O(1);
- доступ к элементам по значению за линейное время O(N);
- вставка в конец в среднем производится за O(1);
- удаление произвольного элемента занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку влево (реальный размер массива не изменяется);
- вставка элемента в произвольное место занимает значительное время т.к. все элементы «правее» смещаются на одну ячейку вправо;
- минимум накладных расходов при хранении.

### LinkedList
- на получение элемента по индексу или значению потребуется O(N);
- но доступ к первому и последнему элементу всегда осуществляется за O(1) — ссылки постоянно хранятся на первый и последний элемент;
- на добавление и удаление в начало или конец потребуется O(1);
- вставка или удаление в/из произвольного место O(1);
- но поиск позиции вставки и удаления за O(N);
- требует больше памяти для хранения такого же количества элементов, из-за указателей на следующий и предыдущий элементы списка.

| Класс          |  Получение  |  Поиск   | :    Вставка    | :  Удаление    |
| :--------------| :-----------| :--------|:----------------|:---------------|
| **ArrayList**  |     O(1)    |   O(n)   |    O(n) / O(1)  |      O(n)      |
| **LinkedList** |     O(n)    |   O(n)   |       O(1)      |      O(1)      |

---

## HasMap
Добавление, поиск и удаление элементов выполняется за константное время. Но хеш-функций должна равномерно распределять элементы по корзинам, в этом случае временная сложность для этих 3 операций будет не ниже O(lgN), а в среднем случае как раз константное время.

---

## Бинарное дерево
Упорядоченный граф, у которого имеется корень (вершина) и ветви влево-вправо. в Левую ветвь заносятся значения меньше, чем в корне, в правую ветвь значения больше корня. В ветвях значения так же сортируются, образуя ответвления от ветви.
**Проблема:** В вырожденном случае может оказаться, что всё левое дерево пусто на каждом уровне, есть только правые деревья, и в таком случае дерево вырождается в список (идущий вправо). Поиск (а значит, и удаление и добавление) в таком дереве по скорости равен поиску в списке и намного медленнее поиска в сбалансированном дереве.

---

## Красно-чёрное дерево
Вид бинарных деревьев, у которых присутствует балансировка — за счет дополнительного атрибута — цвета. Этот атрибут может принимать одно из двух возможных значений — «чёрный» или «красный».

_При этом:_
- Узел может быть либо красным, либо чёрным и имеет двух потомков;
- Корень — как правило чёрный. Это правило слабо влияет на работоспособность модели, так как цвет корня всегда можно изменить с красного на чёрный;
- Все листья — чёрные и не содержат данных. Для экономии памяти листья можно сделать одним общим фиктивным листом.
- Оба потомка каждого красного узла — чёрные.
- Любой простой путь от узла-предка до листового узла-потомка содержит одинаковое число чёрных узлов.

_КЧД реализованны в TreeMap, TreeSet._

---

## Мемоизация

Сохранение результатов выполнения функций для предотвращения повторных вычислений. Перед вызовом функции проверяется, вызывалась ли функция ранее: если не вызывалась, то функция вызывается, и результат её выполнения сохраняется; а если вызывалась, то используется сохранённый результат.