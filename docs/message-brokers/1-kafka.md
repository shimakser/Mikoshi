# Apache Kafka

Распределенная система обмена сообщениями, узлы которой содержатся на нескольких кластерах. Принимая сообщение от
продюсера, она реплицирует (копирует) его, а копии сохраняет на разных узлах. При этом один из брокеров назначается
ведомым в секции, через него потребители будут обращаться к записям. Другие брокеры остаются ведомыми, их главная
задача — обеспечить сохранность сообщения (копий).

Поддерживает «горячее» расширение — ее можно увеличивать с помощью добавления новых машин в кластеры, не отключая всю
систему.

---

## Основные компоненты

**Broker** — Сервер, управляющий хранением и передачей данных. Несколько брокеров образуют кластер.
**Producer** — Приложения, публикующие данные в topic. Сериализуют сообщения, балансируют нагрузку между партициями.
Продюсер может указать ключ у сообщения и сам определяет номер партиции (например, разделяя вычисленный хеш на число
партиций). Так она сохраняет сообщения одного идентификатора в одну и ту же партицию. Что позволяет добиться строгой
очерёдности событий при чтении за счёт сохранения сообщений в одну партицию.
**Consumer** — Приложения, читающие данные из тем (pull-модель). Работают в рамках consumer group для распределения
нагрузки.
Когда несколько консьюмеров читают данные и являются членами одной группы, то каждый из них получает сообщения из разных
партиций топика, распределяя нагрузку.

**Topic** — Логический канал для группировки сообщений.
- Топик состоит из одной и более партиций, распределённых между брокерами внутри одного кластера.
- Сообщения хранятся в той последовательности, в которой поступили.
  Partition — Физическое разделение топика на упорядоченные последовательности сообщений.
  Позволяет:
- Параллельную обработку.
- Репликацию данных.
- Горизонтальное масштабирование.
  В рамках одной группы партиции распределяются между консьюмерами:
- Каждая партиция назначается только одному консьюмеру в группе.
- При этом один консьюмер может обрабатывать несколько партиций.

---

### Acknowledgments

- **acks=0** — Производитель не ждет никаких подтверждений от сервера.
- **acks=1** — Производитель получает подтверждение после того, как ведущая реплика получила данные.
- **acks=all** — Производитель получает подтверждение после того, как все синхронизированные реплики получили данные.

---

### Семантика довставки

- **at-most once** — при доставке сообщений нас устраивают потери сообщений, но не их дубликаты.
  - acks=0 или acks=1.
- **at-least once** — не хотим терять сообщения, но нас устраивают возможные дубликаты 
  - acks=all
  - retries > 0
  - enable.auto.commit=false
- **exactly-once** — хотим доставить одно и только одно сообщение, ничего не теряя и ничего не дублируя.
  - idempotent producer (enable.idempotence=true)
  - transactions
  - acks=all

---

### Rebalance

Когда новый Consumer присоединяется к Consumer Group, Kafka запускает процесс, называемый **Rebalance**:

- Обнаружение: Брокер-координатор группы обнаруживает нового участника.
- Генерация: Координатор сообщает всем участникам группы, что произошёл rebalance.
- Перераспределение: Все потребители временно прекращают чтение. Координатор перераспределяет партиции между всеми
  членами группы (включая нового).
- Возобновление: Каждый потребитель получает новый набор партиций для чтения и возобновляет работу, начиная с
  сохранённых offsets.

---

### Log Compaction
Механизм очистки журнала, сохраняет только последнее значение для каждого ключа сообщения в партиции.

**Tombstone** — это специальное сообщение, которое используется для удаления ключа из логически представленного набора
данных (например, из compacted topic).

- Это запись с ключом (key) и значением = null (value = null`).
- При включённой log compaction такие сообщения приводят к тому, что при чистке лога все более старые значения этого
  ключа будут удалены, а сам tombstone в итоге тоже исчезнет (после истечения delete.retention.ms).

---

### Репликация 
Процесс создания и поддержания копий партиций.

- Создаёте топик и указываете для него фактор репликации (replication factor). Например 3.
- Kafka создаёт для каждой партиции этого топика одну лидер-реплику и две реплики-последователя.
- Kafka старается разместить эти три реплики на разных брокерах.

---

### Идемпотентный producer
- Каждому producer назначается уникальный Producer ID (PID).
- Каждое сообщение получает монотонно возрастающий sequence number.
- Брокер отслеживает комбинации PID + sequence number для каждого раздела и отклоняет дублирующиеся запросы.

---

### Kafka Transactions

**Транзакционный Coordinator** — модуль, работающий внутри каждого брокера Kafka:
- Управление состоянием транзакций.
- Отслеживание разделов транзакции.
- Координацию процесса commit/abort.
- Предотвращение дублирования от "мертвых" producer'ов.

**Журнал транзакций** — внутренний топик с именем __transaction_state. В нем хранится:
- Последнее состояние каждой транзакции (не сами сообщения).
- Метаданные о разделах транзакции.
- Информация о producer'ах и их epochs.

Внутренний механизм работы транзакции
- Producer определяет, какой брокер является координатором для его transactional.id.
- Координатор назначает PID и увеличивает epoch.
- Фиксации через 2PC с записью prepare marker и commit marker.

Kafka поддерживает два уровня изоляции
- read_uncommitted (по умолчанию): Consumer читает все сообщения, включая незафиксированные транзакции.
- read_committed: Consumer видит только сообщения из зафиксированных транзакций и нетранзакционные сообщения.

Важные особенности transactional.id
- Назначение: transactional.id идентифицирует не конкретную транзакцию, а конкретный транзакционный producer. Один producer может выполнить миллионы транзакций, используя один и тот же transactional.id.
- Уникальность: Kafka гарантирует, что только один producer с данным transactional.id может быть активен одновременно. При появлении нового producer со старым ID происходит "zombie fencing" - старый producer блокируется.
- Стабильность: transactional.id должен оставаться неизменным при перезапусках приложения для обеспечения continuity.

Влияние на производительность
- Дополнительная задержка: Consumer в режиме read_committed не может читать сообщения до commit транзакции.
- Накладные расходы: Транзакции добавляют metadata и требуют дополнительных сетевых взаимодействий
- Размер транзакций: Больше сообщений в транзакции = меньше накладных расходов на сообщение, но больше задержка.