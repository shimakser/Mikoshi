# Collections

## Интерфейс Collection расширяют

1. **List**:
   - **ArrayList** — инкапсулирует в себе обычный массив, длина которого автоматически увеличивается при добавлении новых элементов. Элементы пронумерованы, начиная с нуля, к ним можно обратиться по индексу. [Источники](https://habr.com/ru/articles/128269/).
   - **LinkedList** — состоит из узлов, каждый из которых содержит как собственно данные, так и две ссылки на следующий и предыдущий узел. [Источники](https://habr.com/ru/articles/127864/).
   - **Vector** — реализация динамического массива, методы которой синхронизированы.
   - **Stack** — реализация стека LIFO (last-in-first-out).
2. **Set** — неупорядоченная коллекция, не содержащую повторяющихся элементов:
   - **HashSet** — использует HashMap для хранения данных. В качестве ключа используется добавляемый элемент, в качестве значения - заглушка Object. Порядок элементов не гарантируется.
   - **LinkedHashSet** — гарантирует, что порядок коллекции будет идентичен порядку добавления элементов.
   - **TreeSet** — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».
3. **Queue** FIFO (first-in-first-out) очередь:
   - **PriorityQueue** — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».
   - **ArrayDeque** — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out).

---

## Интерфейс Map реализован классами

1. **Hashtable** — хэш-таблица, методы синхронизированы. Не позволяет использовать null в качестве значения или ключа, не является упорядоченной.
2. **HashMap** — позволяет использовать null в качестве значения или ключа и не является упорядоченной. [Источники](https://habr.com/ru/articles/421179/).

   _Bucket_ — это единственный элемент массива HashMap. Он используется для хранения узлов (Nodes). Два или более узла
   могут иметь один и тот -же bucket. В этом случае для связи узлов используется структура данных связанный список.

   Хэш код ключа может быть достаточно большим для создания массива. отому мы генерируем индекс для минимизации размера массива.
   `index = hashCode(key) & (n-1).`
   где n равна числу bucket или значению длины массива. В нашем примере я рассматриваю n, как значение по умолчанию равное 16.

   _Вычисление индекса в HashMap:_
    1. Вычислить значение ключа {"vishal"}. Оно будет сгенерированно, как 118.
    2. Вычислить индекс с помощью метода index, который будет равен 6.
    3. Создать объект node.    
    4. Поместить объект в позицию с индексом 6, если место свободно.
    5. Если на предыдущем шаге (_iv_), при попытке вставки объекта позиция по индексу уже занята:
       - В таком случае проверям с помощью методов hashCode() и equals(), что оба ключа одинаковы.
       - Если ключи одинаковы, заменить текущее значение новым.
       - Иначе связать новый и старый объекты с помощью структуры данных "связанный список", указав ссылку на следующий объект в текущем и сохранить оба под индексом 6.

3. **LinkedHashMap** — упорядоченная реализация хэш-таблицы.
   [Источники](https://habr.com/ru/articles/129037/).
4. **TreeMap** — основано на красно-чёрных деревьях. Является упорядоченной и предоставляет возможность управлять
   порядком
   элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».
5. **WeakHashMap** — реализация хэш-таблицы, которая организована с использованием weak references для ключей (сборщик
   мусора автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элемента нет жёстких
   ссылок).

---

## Fail-fast vs Fail-safe

1. Fail-fast

- Бросают ConcurrentModificationException, если коллекция модифицируется во время итерации.
- Примеры: ArrayList, HashMap, HashSet (обычные).
- Работают через modCount, проверяя при каждом вызове next().

2. Fail-safe:

- Не бросают исключения, потому что используют копию коллекции.
- Поддерживают многопоточность.
- Примеры: CopyOnWriteArrayList, ConcurrentHashMap
- Минусы: могут работать медленнее и потреблять больше памяти.