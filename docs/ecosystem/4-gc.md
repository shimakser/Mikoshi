# Garbage collectors, References

---

## References

В Java ты никогда не работаешь с объектами напрямую — ты всегда работаешь с **ссылками на объекты**, которые хранятся в
куче.

### Типы ссылок

1. Strong
    - _Применение:_ По умолчанию String, Integer, и т.п.
    - _Удаляется GC:_ нет.
2. Weak
    - `WeakReference<Object> ref = new WeakReference<>(new Object());`
    - _Применение:_ WeakHashMap, обработка метаданных.
    - _Удаляется GC:_ Да, немедленно при GC.
   
3. Soft
    - `SoftReference<Object> ref = new SoftReference<>(new Object());`
    - _Применение:_ Кэширование объектов.
    - _Удаляется GC:_ Да, при нехватке памяти.
4. Phantom
    - `PhantomReference<Object> ref = new PhantomReference<>(new Object(), queue);`
    - _Применение:_ Мониторинг завершения объекта, ReferenceQueue.
    - _Удаляется GC:_ Да, но с колбэком.
    - Фантомная ссылка никогда не возвращает объект через get(). Она существует только для отслеживания, когда объект удаляется.

---

## Garbage collectors

GC освобождает память, удаляя объекты, до которых больше нет достижимых ссылок. Разные сборщики оптимизированы под разные цели: пропускная способность (throughput), паузы (latency), размеры хипа.

---

## Основные термины GC

### 1. Поколения памяти (Generational Hypothesis)
Куча делится на поколения:
- Young Gen: Eden + 2 Survivor области
  - Объекты создаются в Eden.
  - Если переживают несколько сборок — переходят в Survivor, потом в Old.
- Old Gen: объекты, живущие дольше — собираются реже.

### 2. Minor / Major / Full GC
| Тип GC       | Где работает            | Описание                                 |
| ------------ | ----------------------- | ---------------------------------------- |
| **Minor GC** | Только Young Generation | Быстрый, частый, копирующий сборщик      |
| **Major GC** | Old Generation          | Медленнее, более тяжёлый                 |
| **Full GC**  | Вся куча                | Останавливает всё, часто признак проблем |
Для малой сборки мусора объект считается мертвым если до него невозможно добраться по ссылкам ни из объектов старшего поколения, ни из корней (roots), к каковым относятся ссылки из стеков потоков, статические члены классов и т. п.

### 3. Stop-the-World (STW)
- Любая сборка мусора вызывает паузу выполнения потоков приложения.
- GC приостанавливает все потоки, чтобы безопасно обойти ссылки.
- Современные GC минимизируют или частично избегают пауз (Concurrent/Parallel GC).

### 4. Mark–Sweep / Copy / Compact
| Этап        | Суть                                          |
| ----------- | --------------------------------------------- |
| **Mark**    | Пометить все достижимые объекты               |
| **Sweep**   | Удалить не помеченные                         |
| **Compact** | Сжать память, устранив фрагментацию           |
| **Copy**    | Переместить выжившие объекты в другую область |

---

## Виды GC

### Serial
- Самый простой для приложений с небольшим объемом данных и не требовательных к задержкам.
- Четыре региона: Eden, Survivor 0 и Survivor 1, Tenured. Объект начинает свою жизнь в Eden, а когда место в регионе заканчивается - запускается сборка мусора. После удаления мёртвых объектов, все оставшиеся переносятся в один из двух Survivor регионов (один из них всегда пуст). Следующая сборка будет очищать Eden и занятый Survivor, перенося выжившие объекты во второй свободный Survivor. Если регион Survivor оказывается заполненным, то объекты из него также отправляются в Tenured. Очень большие объекты сразу размещаются в Tenured.
- Долгие паузы на сборку мусора при заметных объемах данных.
- _STW:_ В начале каждой сборки мусора работа основных потоков приложения останавливается и возобновляется только после окончания сборки.
- _Подходит для:_
  - Приложений с одним ядром,
  - Маленьких heap (до ~100–200MB).
- _Включение:_ `-XX:+UseSerialGC`.

### Parallel
- Количество регионов и процесс сборки мусора как и у Serial.
- По умолчанию и малая и полная сборка задействуют многопоточность. Малая пользуется ею при переносе объектов в старшее поколение, а полная — при уплотнении данных в старшем поколении. Каждый поток сборщика получает свой участок памяти в регионе Old Gen, куда только он может переносить данные, чтобы не мешать другим потокам.
- _STW:_ на время операций по очистке памяти все основные потоки приложения останавливаются.
- Может быть долгий "стоп-мир" при больших хипах.
- _Основная цель:_ максимальная производительность (пропускная способность).
- _Подходит для:_
  -Серверных приложений,
  -Где важна производительность, но паузы некритичны.
- _Включение:_ `-XX:+UseParallelGC` (По умолчанию до JDK 9).

### CMS
- _Принцип:_ Потоки параллельно с приложением собирают мусор.
- Использует ту же самую организацию памяти, что и у Serial/Parallel.
- Малая и старшая сборки здесь всегда разделены — все объекты младшего поколения (даже потенциально мертвые) могут играть роль корней при определении статуса объектов в старшем поколении.
- Не дожидается заполнения Tenured для того, трудится в фоновом режиме постоянно, пытаясь поддерживать Tenured в компактном состоянии.
- Начинается очистки с остановки основных потоков приложения и пометки всех объектов, напрямую доступных из корней. После этого приложение возобновляет свою работу, а сборщик параллельно с ним производит поиск всех живых объектов, доступных по ссылкам из тех самых помеченных корневых объектов (в одном или в нескольких потоках). Затем сборщик еще раз приостанавливает работу приложения и просматривает кучу для поиска живых объектов, ускользнувших от него за время первого прохода. После того, как живые объекты помечены, работа основных потоков приложения возобновляется, а сборщик производит очистку памяти от мертвых объектов в нескольких параллельных потоках.
- Старается разносить во времени малые и старшие сборки мусора, чтобы они совместно не создавали продолжительных пауз в работе приложения.
- _STW:_ Малая сборка - не отличается от Parallel. Начальная фаза поиска живых объектов - очень короткая. Фаза дополнения набора живых объектов- длиннее начальной фазы поиска.
- Меньшие паузы, чем у Parallel GC.
- _Включение:_ `-XX:+UseConcMarkSweepGC` (Deprecated с JDK 9, удалён в JDK 14).

### G1
- По умолчанию с JDK 9.
- Создан для замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных.
- Те же регионы поколение, но тут они не обязаны идти подряд и могут менять свою принадлежность.
- Малая сборка выполняется не на всем поколении, а только на части регионов, которые сборщик сможет очистить не превышая желаемого времени.
- Над переносом объектов трудятся несколько потоков, и на время этого процесса работа основного приложения останавливается.
- Выбирает для очистки те регионы, в которых, по его мнению, скопилось наибольшее количество мусора и очистка которых принесет наибольший результат.
- В G1 существует процесс, называемый циклом пометки (marking cycle), который работает параллельно с основным приложением и составляет список живых объектов.
- Громадные объекты никогда не перемещаются между регионами. В регионы к громадным объектам никого не подселяют.
- Баланс между: Высокой производительностью и Короткими паузами.
- Хорош для средних и больших хипов (от 4–8 ГБ и выше).
- _Включение:_ `-XX:+UseG1GC` (по умолчанию с JDK 9).

### ZGC
- С JDK 11.
- Пытается удерживать паузы на субмиллисекундном уровне, даже при работе с очень большими кучами. Почти вся работа — фоновая.
- Позволяет выполнять большую часть работы по сборке мусора не останавливая работу основных потоков приложения.
- Паузы: < 1 мс даже при хипе сотни гигабайт.
- Использует coloring pointers и load barriers.
- Подходит для: Больших приложений, где важны сверхмалые задержки.
- Поддержка хипа до ~16 ТБ.
- Лучше работает на Oracle JDK, GraalVM, macOS, ARM64 и других менее стандартных окружениях.
- _Включение:_ `-XX:+UseZGC` (начиная с JDK 11).

### Epsilon
- Вообще не собирает мусор, а просто завершает работу приложения сразу, как только оно попыталось аллоцировать больше памяти, чем ему дозволено.
- Когда какому-либо потоку не удается получить очередной буфер из кучи по причине исчерпания ее ресурсов, другие сборщики могут запустить цикл сборки и попробовать высвободить недостающее место, а Epsilon GC просто генерирует OutOfMemoryError и завершает процесс.
- Отказ от сборки мусора означает и отказ от больших накладных расходов на тщательный учет объектов.
- Мусор обычно есть и приводит к фрагментации памяти, занятой живыми объектами, что потенциально может сказываться на скорости доступа к ним.

### Shenandoah
- С JDK 12.
- Нацеленный на ультракороткие паузы независимо от размера кучи.
- При размещении объекта в памяти JVM добавляет к нему заголовок с метаданными, используемыми при блокировках, хэшировании, работе других сборщиков, а также указатель на класс этого объекта. При использовании Shenandoah накладные расходы на хранение каждого объекта немного увеличиваются и перед упомянутым заголовком добавляется указатель перенаправления (indirection pointer). Это указатель на базовый Java-объект, но при наличии копии этого объекта (появившейся в результате перемещения при сборке мусора) он указывает на целевую версию этого объекта.
- Организует кучу, разбивая ее на большое количество регионов равных размеров.
- Работает отлично в условиях, когда у сборщика достаточно ресурсов и он поспевает за приложением, вовремя высвобождая память под новые объекты. Но если он вдруг перестает справляться (Failure Mode), есть план Б: задействует механизм Pacing — начинает чуть-чуть притормаживать самые активные в части аллоцирования памяти потоки приложения, чтобы они создавали новые объекты не так быстро.
- Когда Pacing'а недостаточно, в дело вступает механизм Degenerated GC, в котором конкурентые фазы сборки на время перестают быть конкурентными и начинают выполняться в рамках паузы STW. Зачастую включение такого режима попадает на уже запущенный цикл сборки и тогда пауза распространяется только на его оставшуюся часть. Здесь нужно иметь в виду, что сборка в рамках STW выполняется быстрее, чем в конкурентном режиме, поэтому новые паузы на практике не такие большие, как может показаться на первый взгляд.
- Паузы: 10–20 мс, независимо от хипа.
- Хорош для: Приложений с жёсткими требованиями к латентности.
- Тесно интегрирован с Red Hat, Amazon Corretto, OpenJDK.
- _Включение:_ `-XX:+UseShenandoahGC` (JDK 12+, нужно включить модуль).

---

## Сравнение GC, какой выбрать


### Отладка таймингов - Epsilon.
- Если тебе нужно простое решение для маленького приложения с небольшим объёмом памяти и однопоточной нагрузкой — Serial.
- Если приоритет — максимальная производительность и высокая пропускная способность, а паузы некритичны — Parallel.
- Если нужна устойчивая работа с умеренными паузами и разумный баланс между задержкой и производительностью, безопасный выбор — G1.
- Если приложение работает с очень большим объёмом данных (десятки или сотни гигабайт) и критична сверхнизкая задержка, используй ZGC.
- Если нужна низкая латентность даже при большом heap и тых работаешь с реактивными или real-time системами, рассмотрим Shenandoah.

### ZGC vs Shenandoah
- Shenandoah работает быстрее при низкой производительности.
- Shenandoah предпочтительнее, когда ресурсы процессора критичны.
- ZGC более стабилен.
- ZGC задержки меньше.