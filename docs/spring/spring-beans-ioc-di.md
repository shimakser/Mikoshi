# Spring: Beans, IOC, DI, Conditions

## Lifecycle

1. XmlBeamDefinitionReader - сканирует xml файл и cоздаёт BeanDefinition'ы(объекты, хранящие в себе информации про бины). Каждый BeanDefinition помещается в Map<String, BeanDefinition>, где String - id бина.
2. BeanFactoryPostProcessor - настраивает BeanDefinition'ы до создания на их основе бинов.
3. Создание кастомных FactoryBean.
4. BeanFactory (реализация паттерна фабрика, отвечает за создание и хранение всех объектов) - читает BeanDefinitions, создаёт бины, имплиментирующие интерфейс BeanPostProcessor (позволяет вклиниться в процесс настройки ваших бинов до того, как они попадут в контейнер).
5. BeanFactory создаёт пользовательские бины при необходимости делегируя это на FactoryBean. Настраивает их. Затем прогоняет их через все BeanPostProcessor. Далее у бинов вызываются методы init, после чего их вновь прогоняют через все BeanPostProcessor. Затем они попадают в контейнер.

Синглтоны создаются при запуске программы. Протатайпы при запросе данного бина у спринга.

---

## Bean scopes

- **Singleton** — Определяет один единственный бин для каждого контейнера Spring IoC (используется по умолчанию).
- **Prototype** — Позволяет иметь любое количество экземпляров бина. Новый экземпляр бина создается каждый раз, когда бин необходим в качестве зависимости. Как правило, используется для бинов с сохранением состояния(stateful)
- **Request** — Создаётся один экземпляр бина на каждый HTTP запрос.
- **Session** — Создаётся один экземпляр бина на каждую HTTP сессию.
- **Global-session** — Создаётся один экземпляр бина на каждую глобальную HTTP сессию.
- **Application** — Жизненный цикл экземпляра ограничен в пределах ServletContext.
- **WebSocket** — При первом обращении к бинам с привязкой к WebSocket они сохраняются в атрибутах сессии WebSocket. Затем один и тот же экземпляр бина возвращается при каждом обращении к нему в течение всего сеанса WebSocket.
- **RefreshScope** — Позволяет динамически обновлять бины при изменении конфигурации, без перезапуска приложения.

---

## DI and IoC

### Inversion of Control
Вместо ручного внедрения зависимостей, фреймворк забирает ответственность за это посредством контейнера. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой.

### Dependency Lookup (Поиск зависимости) 
Шаблон проектирования, в котором вызывающий объект запрашивает у объекта-контейнера экземпляр объекта с определённым именем или типом.

### Dependency Injection (Внедрение зависимости)
Шаблон проектирования, в котором контейнер передает экземпляры объектов по их имени другим объектам с помощью конструктора, свойства или фабричного метода.

Процесс внедрения зависимостей в бины при инициализации называется Spring Bean Wiring. Считается хорошей практикой задавать явные связи между зависимостями, но в Spring предусмотрен дополнительный механизм связывания @Autowired. Аннотация может использоваться над конструктор, поле, сеттер-метод или метод конфигурации для связывания по типу. Если в контейнере не будет обнаружен необходимый для вставки бин, то будет выброшено исключение, либо можно указать @Autowired(required = false), означающее, что внедрение зависимости в данном месте не обязательно.

---

## Паттерны Spring

- **Chain of Responsibility** — это поведенческий паттерн, позволяющий передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.
- **Singleton** — гарантирует, что в памяти будет существовать только один экземпляр объекта, который будет предоставлять сервисы. Spring область видимости бина (scope) по умолчанию равна singleton и IoC-контейнер создаёт ровно один экземпляр объекта на Spring IoC-контейнер. Spring-контейнер будет хранить этот единственный экземпляр в кэше синглтон-бинов, и все последующие запросы и ссылки для этого бина получат кэшированный объект.
- **Model View Controller** — Преимущество Spring MVC в том, что ваши контроллеры являются POJO, а не сервлетами. Это облегчает тестирование контроллеров. Стоит отметить, что от контроллеров требуется только вернуть логическое имя представления, а выбор представления остаётся за ViewResolver. Это облегчает повторное использование контроллеров при различных вариантах представления.
- **Front Controller** — Spring предоставляет DispatcherServlet, чтобы гарантировать, что входящий запрос будет отправлен вашим контроллерам. Паттерн используется для обеспечения централизованного механизма обработки запросов, так что все запросы обрабатываются одним обработчиком. Этот обработчик может выполнить аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем передать запрос соответствующему контроллеру.
- **Dependency injection и Inversion of control (IoC)** — IoC-контейнер в Spring, отвечает за создание объекта, связывание объектов вместе, конфигурирование объектов и обработку всего их жизненного цикла от создания до полного уничтожения. В контейнере Spring используется инъекция зависимостей (Dependency Injection, DI) для управления компонентами приложения. Эти компоненты называются "Spring-бины" (Spring Beans).
- **Service Locator** — ServiceLocatorFactoryBean сохраняет информацию обо всех бинах в контексте. Когда клиентский код запрашивает сервис (бин) по имени, он просто находит этот компонент в контексте и возвращает его. Клиентскому коду не нужно писать код, связанный со Spring, чтобы найти бин. Паттерн Service Locator используется, когда мы хотим найти различные сервисы, используя JNDI. Учитывая высокую стоимость поиска сервисов в JNDI, Service Locator использует кеширование. При запросе сервиса первый раз Service Locator ищет его в JNDI и кэширует объект. Дальнейший поиск этого же сервиса через Service Locator выполняется в кэше, что значительно улучшает производительность приложения.
- **Observer** — Используется в механизме событий ApplicationContext. Определяет зависимость "один-ко-многим" между объектами, чтобы при изменении состояния одного объекта все его подписчики уведомлялись и обновлялись автоматически.
- **Context Object** — Паттерн инкапсулирует системные данные в объекте-контексте для совместного использования другими частями приложения без привязки приложения к конкретному протоколу. ApplicationContext является центральным интерфейсом в приложении Spring для предоставления информации о конфигурации приложения.
- **Proxy** — позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.
- **Factory** — определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.
- **Template** — паттерн широко используется для работы с повторяющимся бойлерплейт кодом (таким как, закрытие соединений и т. п.).

---

## Conditions

- **ConditionalOnBean** — если присутствует нужный бин в BeanFactory.
- **ConditionalOnClass** — если нужный класс есть в classpath.
- **ConditionalOnCloudPlatform** — когда активна определенная платформа.
- **ConditionalOnExpression** — когда SpEL выражение вернуло положительное значение.
- **ConditionalOnJava** — когда приложение запущено с определенной версией JVM.
- **ConditionalOnJndi** — только если через JNDI доступен определенный ресурс.
- **ConditionalOnMissingBean** — если нужный бин отсутствует в BeanFactory.
- **ConditionalOnMissingClass** — если нужный класс отсутствует в classpath.
- **ConditionalOnNotWebApplication** — если контекст приложения не является веб контекстом.
- **ConditionalOnProperty** — если в файле настроек заданы нужные параметры.
- **ConditionalOnResource** — если присутствует нужный ресурс в classpath.
- **ConditionalOnSingleCandidate** — если bean-компонент указанного класса уже содержится в BeanFactory и он единственный.
- **ConditionalOnWebApplication** — если контекст приложения является веб контекстом.