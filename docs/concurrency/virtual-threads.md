# Virtual threads

Традиционно использовалась модель «один поток на запрос», в которой для обработки каждого запроса создавался отдельный поток на протяжении всего жизненного цикла запроса. Эти платформенные потоки реализованы как обёртки вокруг потока операционной системы. Однако потоки ОС потребляют значительное количество системной памяти и управляются на уровне операционной системы, что может приводить к проблемам с масштабированием при увеличении их числа.

Виртуальные потоки решают эту проблему, создавая каждый поток как легковесный объект в куче Java и назначая потоки ОС только по мере необходимости.
Каждый виртуальный поток мапится не напрямую на системный поток, а мультиплексируется на общий пул.

## Процесс Mount/Unmount
JVM поддерживает пул платформенных потоков, количество которых изначально равно количеству ядер CPU.
Когда виртуальный поток выполняется:
- Mount: Виртуальный поток привязывается к carrier thread.
- Выполнение: Код выполняется на платформенном потоке.
- Unmount: При блокирующей операции виртуальный поток освобождает carrier thread.
- Планировка: Освобожденный carrier thread может выполнять другие виртуальные потоки.
- Re-Mount: Как только блокирующая операция завершается (например, пришли данные из сети), JVM получает уведомление и снова ставит виртуальный поток в очередь на выполнение. Как только освободится поток-носитель, виртуальный поток будет снова смонтирован на него и продолжит свою работу с того места, где остановился.

## Характеристика
- Лучше подходят для смешанных workloads, включающих CPU и I/O операции.
- Нужно быть осторожным с тем, что использует локальные переменные потока для кэширования — вы можете создать гораздо больше виртуальных потоков, чем потоков платформы, в итоге можете получить большое потребление памяти вашими виртуальными потоками, использующими локальное хранилище потока таким образом, что сборщик мусора не будет его очищать, пока поток не завершится (как вы и ожидаете при использовании локального хранилища потока).

## Не рекомендуются для
- CPU-интенсивных задач.
- Долгоживущих операций: длительные вычисления без блокировок.
- Использования с synchronized: может привести к thread pinning (Рекомендуется использовать ReentrantLock).

### Пример
    Thread virtualThread = Thread.ofVirtual()
        .name("virtual-worker-1")
        .start(() -> {
            System.out.println("Выполняется в: " + Thread.currentThread().getName());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
    });

### Использование с ExecutorService
    try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
        for (int i = 0; i < 1_000_000; i++) {
            executor.submit(() -> {
                // I/O операции эффективно обрабатываются
                performDatabaseQuery();
                makeHttpRequest();
            });
        }
    }

### Spring Boot интеграция
    spring.threads.virtual.enabled=true