# Threads

**Приоритет потока** — это число от 1 до 10, в  зависимости от которого, планировщик потоков выбирает какой поток  запускать. Однако полагаться на приоритеты для предсказуемого выполнения многопоточной  программы нельзя!

---

### Способы создания потока
1. **extends Thread** and **Override run()**.

       public class MyThread extends Thread {
           @Override
           public void run() {
               System.out.println("Поток работает (Thread): " + Thread.currentThread().getName());
           }
       }
    _Запустить:_

       MyThread thread = new MyThread();
       thread.start();

2. **impliments Runnable** and **Override run()**.

       public class MyRunnable implements Runnable {
           @Override
           public void run() {
               System.out.println("Поток работает (Runnable): " + Thread.currentThread().getName());
           }
       }
    _Запустить:_

       Thread thread = new Thread(new MyRunnable());
       thread.start();
3. Через ExecutorService, используя utility-класс Executors.
   
- _Executor_ — это базовый интерфейс для запуска задач в разных потоках. Он определяет всего один метод:


    Executor executor = new Executor() {
       @Override
       public void execute(Runnable command) {
          new Thread(command).start();
       }
    };
    
    executor.execute(() -> System.out.println("Task executed in a separate thread"));

- _ExecutorService_ — расширяет функциональность Executor и предоставляет более продвинутые возможности для управления пулом потоков, завершения задач и ожидания завершения всех задач. Основные методы включают:
  - _submit(Callable<T> task)_ — возвращает объект Future, который позволяет получить результат задачи или узнать статус выполнения.
  - _shutdown()_ — корректно завершает работу сервиса, прекращая принимать новые задачи, но давая завершиться уже запущенным.
- _invokeAll(), invokeAny()_ — позволяют выполнить коллекцию задач и получить результаты.

      ExecutorService executorService = Executors.newFixedThreadPool(2); // создаем пул из 2 потоков

      Callable<String> task = () -> {
          Thread.sleep(2000); // симуляция долгой задачи
          return "Task result";
      };

      Future<String> future = executorService.submit(task);

      try {
          String result = future.get(); // ожидаем завершения задачи и получаем результат
          System.out.println("Task result: " + result);
      } catch (Exception e) {
          e.printStackTrace();
      } finally {
          executorService.shutdown(); // завершаем работу ExecutorService
      }

---

### Демоны
Это потоки, которое работают в фоновом  режиме и не гарантируют что они завершатся. Тоеть если все потоки завершились, то поток демон просто
обрывается вместе с закрытием приложения.

### Зелёные потоки
Потоки эмулируемые виртуальной машиной или средой исполнения. Создание зелёного потока не подразумевает под собой создание реального потока ОС.
JVM берёт на себя заботу о переключении между разными green threads, а сама машина работает как один поток ОС. Потоки ОС относительно дороги в большинстве POSIX-систем. Переключение между native threads гораздо медленнее, чем между green threads. Это всё означает, что в некоторых ситуациях green threads гораздо выгоднее, чем native threads.

---

### Thread жизненный цикл
New  —  поток находится в состоянии New, когда создается экземпляр объекта класса Thread, но метод start не вызывается.
Runnable  —  когда для объекта Thread был вызван метод start. В этом состоянии поток либо ожидает, что планировщик заберет его для выполнения, либо уже запущен. Назовем состояние, когда поток уже выбран для выполнения, “работающим” (running).
Non-Runnable(Blocked , Timed-Waiting)  —  когда поток жив, то есть объект класса Thread существует, но не может быть выбран планировщиком для выполнения. Он временно неактивен.
Terminated  —  когда поток завершает выполнение своего метода run, он переходит в состояние terminated (завершен). На этом этапе задача потока завершается.

---

### Runnable и Callable
- Интерфейс Runnable появиля в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent.
- Классы, реализующие  интерфейс Runnable должны реализовывать метод run(). Классы, реализующие интерфейс Callable должны реализовывать метод call().
- Метод Runnable.run() не возвращает никакого значения, его тип void, а метод Callable.call() может возвращать значение типа T.
- Метод run() не может бросить проверяемое исключение, метод call() может.

Несмотря на то, что start() вызывает метод run() внутри себя, это не то же самое, что просто вызов run(). Если run() вызывается как обычный метод, то он вызывается в том же потоке и никакой новый поток не запускается, как это происходит, в случае, когда вы вызываете метод start().

---

### ThreadLocal переменные
Специальный вид переменных, отличаются от обычных тем, что у каждого потока свой собственный, индивидуально инициализируемый экземпляр переменной, доступ к которой он получает через методы get() или set(). Предоставляет абстракцию над локальными переменными по отношению к потоку.