# Synchronization

**Синхронизация** — процесс, который позволяет выполнять потоки параллельно.

---

## Способы Синхронизации:
1. Системная синхронизация с использованием wait/notify. Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait, предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify (опять же, предварительно захватив монитор бъекта), в результате чего, ждущий на объекте поток "просыпается" и продолжает свое выполнение.
2. Системная синхронизация с использованием join. Метод join, вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связаный с этим экземпляром, закончит работу.
3. Использование классов из пакета java.util.concurrent, который предоставляет набор классов для организации межпоточного взаимодействия. Примеры таких классов - Lock, семафор (Semaphore), etc. Концепция данного подхода заключается в использовании атомарных операций и переменных.

---

### synchronized
При входе в synchronized метод или блок поток обновляет содержимое локальной памяти, а при выходе записывает изменения, сделанные в локальной памяти, в главную. Т.к. все операции с памятью происходят раньше освобождения монитора и освобождение монитора происходит раньше захвата монитора, то все операции с памятью, которые были сделаны потоком до выхода из synchronized блока должны быть видны любому потоку, который входит в synchronized блок для того же самого монитора.

### final
После того как объект был корректно создан, любой поток может видеть значения его final полей без дополнительной синхронизации.

---

-  yield() — пытается сказать планировщику потоков, что нужно выполнить другой поток, что ожидает в очереди на выполнение. Метод не пытается перевести текущий поток в состояние блокировки, сна или ожидания. Он просто пытается его перевести из состояние "работающий" в состояние "работоспособный". Однако выполнение метода может вообще не произвести никакого эффекта. состояние потока остатаётся RUNNABLE.
-  sleep() — приостанавливает поток на указанное. состояние меняется на TIMED_WAITING, по истечению - RUNNABLE
-  wait() — меняет состояние потока на WAITING может быть вызвано только у объекта владеющего блокировкой, в противном случае выкинется исключение IllegalMonitorStateException. при срабатывании метода блокировка отпускается, что позволяет продолжить работу другим потокам ожидающим захватить ту же самую блокировку . в случае
-  wait(int) — с аргументом состояние будет TIMED_WAITING.
- join() — ожидать завершения потока (t1; t2 : t1.join() будет ждать пока t2 выполнится).
- sleep() — При вызове этого метода, поток переходит  в спящее состояние, после сна,
поток переходит в пул потоков и  находится в состоянии "работоспособный", т.е. не гарантируется что после пробуждения он будет сразу выполняться. Также поток не может усыпить другой поток, так как
метод sleep - это статический метод! Вы просто усыпите текущий поток и
не более того! Также метод sleep() может возбуждать InterruptedException().

Thread.sleep() и Thread.yield():
- yield() — поток переходит из состояния работающий (running) в состояние работоспособный (runnable), давая возможность другим потокам активизироваться. Но следующий выбранный для запуска поток может и не быть другим.
- sleep() — вызывает засыпание текущего потока на заданное время, состояние изменяется с работающий (running) на ожидающий (waiting).

---

## Wait & Notify

### Как работают
- wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()/notifyAll();
- notify(): продолжает работу потока, у которого ранее был вызван метод wait();
- notifyAll(): возобновляет работу всех потоков, у которых ранее был вызван метод wait().

Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в состояние Ожидания (Waiting). Метод notify() подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в состояние Работоспособный (Runnable). При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным. Метод notifyAll() заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable). Если ни один поток не находится в ожидании на методе wait(), то при вызове notify() или notifyAll() ничего не происходит.

Поток может вызвать методы wait() или notify() для определённого объекта, только если он в данный момент имеет блокировку на этот объект. wait(), notify() и notifyAll() должны вызываться только из синхронизированного кода.

wait и notify/notifyAll — могут вызваны только потоком, который захватил монитор объекта, для которого эти методы вызываются. То есть они вызываются внутри блока synchronized и для объекта, монитор которого этим synchronized захвачен. Если внутри synchronized метода — то для класса, к которому относятся эти методы.

Почему методы wait и notify вызываются в синхронизированном блоке?
1. Java API обязательно требует этого. Если вы вызовете их не из синхронизированного блока, ваш код выбросит IllegalMonitorStateException.
2. Чтобы избежать состояния гонки между вызовами wait и notify.