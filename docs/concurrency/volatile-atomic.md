# Volatile & Atomic


**Volatile** — модификатор вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной.
Запись таких переменных производится в основную память, минуя локальную. То есть значение переменной не может сохраняться в регистрах или локальной памяти потока. Гарантирует ее видимость во всех потоках.
Если переменная примитивного типа – этого будет достаточно для обеспечения потокобезопасности. Если же переменная является ссылкой на объект – синхронизировано будет исключительно значение ссылки. Все же данные, содержащиеся в объекте, синхронизированы не будут!

Однако volatile не обеспечивает атомарности и синхронизации, поэтому при необходимости следует использовать дополнительные механизмы синхронизации.

---

С другой стороны, атомарные переменные - это переменные, использующие низкоуровневые операции процессора, и они обеспечивают неблокируемое изменение переменных несколькими потоками. Составные операции, выполняемые атомарными переменными, являются атомарными, т.е. выполняются как единая, неделимая операция, и безопасны для потоков. Атомарные переменные минимизируют синхронизацию и помогают избежать ошибок согласованности памяти.

### Atomic классы
Пакет java.util.concurrent.atomic содержит девять классов для выполнения атомарных операций. Операция называется атомарной, если её можно безопасно выполнять при параллельных вычислениях в нескольких потоках, не используя при этом ни блокировок, ни синхронизацию synchronized.
- AtomicBoolean, AtomicInteger, AtomicLong, AtomicReference.
- AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray.
- AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater.
- AtomicStampedReference, AtomicMarkableReference.

---

Volatile следует использовать, когда необходимо обеспечить видимость изменений в разных потоках, но при необходимости следует использовать дополнительные механизмы синхронизации совместно с ним.
Атомарные переменные используются, когда необходимо выполнить атомарные операции над переменной и избежать накладных расходов на синхронизацию одной примитивной переменной, что делает ее более эффективной, чем использование механизма синхронизации/блокировки.