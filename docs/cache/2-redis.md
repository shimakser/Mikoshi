# Redis

Key-Value хранилище.

### Характеристики

1. Клиент-серверная архитектура:

- Redis запускается как отдельный процесс.
- Клиенты подключаются к Redis по TCP или через Unix socket.

2. Операции атомарны, даже инкремент счётчика.
3. Все данные хранятся в оперативной памяти.
4. Поддержка персистентности (может сохранять данные на диск, чтобы они не потерялись при перезапуске сервера или сбое
   питания) — через:

- RDB (snapshot): снимки памяти через интервалы.
- AOF (Append Only File): лог всех операций, которые можно воспроизвести.
- Можно использовать оба одновременно (RDB + AOF).

5. Однопоточность — Все команды выполняются последовательно — нет гонки потоков.
6. TTL — это срок действия ключа (в секундах или миллисекундах). Когда TTL истекает, ключ автоматически удаляется, и
   память освобождается.

- TTL надо назначать вручную через EXPIRE или @Cacheable(..., ttl=...).
- Без TTL Redis может заполниться.

7. Если память заканчивается — Redis может начать сбрасывать ключи или отказывать.

---

### Eviction Policies

Если оперативная память ограничена и переполняется, Redis начинает удалять старые ключи согласно выбранной eviction
policy:

- noeviction — По умолчанию. Новые записи отклоняются, ошибка (OOM).
- allkeys-lru — Удаляет любой ключ, наименее недавно использованный (LRU).
- volatile-lru — Удаляет только ключи с TTL, наименее недавно использованные.
- allkeys-random — Удаляет любой случайный ключ.
- volatile-random — Удаляет случайный ключ с TTL.
- volatile-ttl — Удаляет ключи с наименьшим TTL.
- volatile-lfu — Удаляет редко используемые ключи с TTL (LFU).
- allkeys-lfu — Удаляет редко используемые ключи, даже без TTL.

---

### Репликация

Копирование данных с одного primary-узла на replica-узлы.

Преимущества:

- Распределение нагрузки на чтение,
- Повышение надёжности.

Особенности:

- Реплики только читают (по умолчанию),
- Можно настроить read-only no и писать (не рекомендуется),
- Реплика может отставать при большой нагрузке.

---

### Кластеризация

Масштабирование Redis по нескольким узлам с автоматическим распределением данных.
Как работает:

- Redis делит ключи на 16384 хеш-слота,
- Каждый узел отвечает за диапазон слотов,
- Поддержка автоматического failover'а и репликации.

---

### Шардирование

Разделение данных на части (шарды), каждая из которых хранится на отдельном узле. В Redis это реализовано с помощью
Redis Cluster.

Как работает:

- Redis делит все возможные ключи по 16384 хеш-слотам,
- Каждый узел в кластере отвечает за определённый диапазон слотов,
- Ключ автоматически попадает в нужный слот.

---

### Redis Sentinel

Это механизм для мониторинга, обнаружения сбоев и автоматического failover'а в Redis с репликацией.

Что делает:

- Мониторинг Redis-узлов (мастера и реплик).
- Если мастер не отвечает, Sentinel считает его недоступным.
- Failover: автоматически продвигает одну из реплик в мастера.
- Уведомление клиентов о новом мастере.

---

### Code config:

1. `@CacheConfig` — на уровне класса, позволяет задать общие параметры для всех методов.

- cacheNames — Кэш по умолчанию для всех методов.
- keyGenerator — Кастомный генератор ключей.
- cacheManager.
- cacheResolver — Альтернатива cacheManager.

2. `@Cacheable`

- value — имя кэша,
- key — SpEL-выражение для ключа,
- unless — не кэшировать, если условие истинно,
- condition — кэшировать только если условие истинно.

3. `@CachePut` — Всегда вызывает метод и обновляет кэш.
4. `@CacheEvict` — Удаляет элемент из кэша:

- allEntries = true — удаляет все элементы из кэша,
- beforeInvocation = true — удаляет до вызова метода.

---

### Transactions & ACID

- Redis поддерживает транзакции через команды MULTI, EXEC, DISCARD и WATCH.
- Все команды транзакции выполняются последовательно и изолированно.
- Не обеспечивает полную ACID-атомарность: если одна команда внутри транзакции неудачна, остальные команды всё равно
  выполняются.